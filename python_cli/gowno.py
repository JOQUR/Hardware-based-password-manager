# Code generated by bitproto. DO NOT EDIT.


import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List, Union
from enum import IntEnum, unique

from bitprotolib import bp


@dataclass
class AESEncrypt(bp.MessageBase):
    # Number of bytes to serialize class AESEncrypt
    BYTES_LENGTH: ClassVar[int] = 67

    input: List[int] = field(default_factory=lambda: [0 for _ in range(64)]) # 512bit
    size: int = 0 # 16bit
    encrypt: bool = False # 1bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 64, bp.Uint(8))),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
            bp.MessageFieldProcessor(3, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 529, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.input[di.i(0)] |= (int(b) << lshift)
        if di.field_number == 2:
            self.size |= (int(b) << lshift)
        if di.field_number == 3:
            self.encrypt = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.input[di.i(0)] >> rshift) & 255
        if di.field_number == 2:
            return (self.size >> rshift) & 255
        if di.field_number == 3:
            return (int(self.encrypt) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class AESResponse(bp.MessageBase):
    # Number of bytes to serialize class AESResponse
    BYTES_LENGTH: ClassVar[int] = 66

    response: List[int] = field(default_factory=lambda: [0 for _ in range(64)]) # 512bit
    size: int = 0 # 16bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 64, bp.Uint(8))),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
        ]
        return bp.MessageProcessor(False, 528, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.response[di.i(0)] |= (int(b) << lshift)
        if di.field_number == 2:
            self.size |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.response[di.i(0)] >> rshift) & 255
        if di.field_number == 2:
            return (self.size >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class PublicKeyExchange(bp.MessageBase):
    # Number of bytes to serialize class PublicKeyExchange
    BYTES_LENGTH: ClassVar[int] = 32

    pub_key: List[int] = field(default_factory=lambda: [0 for _ in range(32)]) # 256bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 32, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 256, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.pub_key[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.pub_key[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@unique
class MessageResponse(IntEnum): # 3bit
    ACK = 0
    NACK = 1


# Aliases for backwards compatibility
ACK: MessageResponse = MessageResponse.ACK
NACK: MessageResponse = MessageResponse.NACK


_MESSAGERESPONSE_VALUE_TO_NAME_MAP: Dict[MessageResponse, str] = {
    MessageResponse.ACK: "ACK",
    MessageResponse.NACK: "NACK",
}

def bp_processor_MessageResponse() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(3))


@unique
class MesssageType(IntEnum): # 3bit
    PUBLIC_KEY_ECHANGE = 0


# Aliases for backwards compatibility
PUBLIC_KEY_ECHANGE: MesssageType = MesssageType.PUBLIC_KEY_ECHANGE


_MESSSAGETYPE_VALUE_TO_NAME_MAP: Dict[MesssageType, str] = {
    MesssageType.PUBLIC_KEY_ECHANGE: "PUBLIC_KEY_ECHANGE",
}

def bp_processor_MesssageType() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(3))


@dataclass
class Msg(bp.MessageBase):
    # Number of bytes to serialize class Msg
    BYTES_LENGTH: ClassVar[int] = 1

    msg: Union[int, MesssageType] = MesssageType.PUBLIC_KEY_ECHANGE
    # This field is a proxy to hold integer value of enum field 'msg'
    _enum_field_proxy__msg: int = field(init=False, repr=False) # 3bit
    res: Union[int, MessageResponse] = MessageResponse.ACK
    # This field is a proxy to hold integer value of enum field 'res'
    _enum_field_proxy__res: int = field(init=False, repr=False) # 3bit

    def __post_init__(self):
        # initialize handling of enum field 'msg' as `enum.IntEnum`
        if not isinstance(getattr(Msg, "msg", False), property):
            self._enum_field_proxy__msg = self.msg
            Msg.msg = property(Msg._get_msg, Msg._set_msg)  # type: ignore
        # initialize handling of enum field 'res' as `enum.IntEnum`
        if not isinstance(getattr(Msg, "res", False), property):
            self._enum_field_proxy__res = self.res
            Msg.res = property(Msg._get_res, Msg._set_res)  # type: ignore

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_msg(self) -> MesssageType:
        """property getter for enum proxy field"""
        return MesssageType(self._enum_field_proxy__msg)

    def _set_msg(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__msg = val
    def _get_res(self) -> MessageResponse:
        """property getter for enum proxy field"""
        return MessageResponse(self._enum_field_proxy__res)

    def _set_res(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__res = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_MesssageType()),
            bp.MessageFieldProcessor(2, bp_processor_MessageResponse()),
        ]
        return bp.MessageProcessor(False, 6, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.msg |= (MesssageType(b) << lshift)
        if di.field_number == 2:
            self.res |= (MessageResponse(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.msg >> rshift) & 255
        if di.field_number == 2:
            return (self.res >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return