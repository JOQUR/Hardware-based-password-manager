# Code generated by bitproto. DO NOT EDIT.


import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List, Union
from enum import IntEnum, unique

from bitprotolib import bp


@unique
class MessageId(IntEnum): # 8bit
# send public Key Exchange, rsp: InitializeCommRsp
    INITIALIZE_COMM = 0
# sends random 16 bytes as an challange, rsp: ChallangeRsp
    CHALLANGE = 1
# Finish Handshake sending true/false, rsp: HandshakeFinishedRsp
    HANDSHAKE_FINISHED = 2
# Add user
    CREATE_USER = 3
# Add users password and info
    ADD_PASSWORD = 4


# Aliases for backwards compatibility
# send public Key Exchange, rsp: InitializeCommRsp
INITIALIZE_COMM: MessageId = MessageId.INITIALIZE_COMM
# sends random 16 bytes as an challange, rsp: ChallangeRsp
CHALLANGE: MessageId = MessageId.CHALLANGE
# Finish Handshake sending true/false, rsp: HandshakeFinishedRsp
HANDSHAKE_FINISHED: MessageId = MessageId.HANDSHAKE_FINISHED
# Add user
CREATE_USER: MessageId = MessageId.CREATE_USER
# Add users password and info
ADD_PASSWORD: MessageId = MessageId.ADD_PASSWORD


_MESSAGEID_VALUE_TO_NAME_MAP: Dict[MessageId, str] = {
    MessageId.INITIALIZE_COMM: "INITIALIZE_COMM",
    MessageId.CHALLANGE: "CHALLANGE",
    MessageId.HANDSHAKE_FINISHED: "HANDSHAKE_FINISHED",
    MessageId.CREATE_USER: "CREATE_USER",
    MessageId.ADD_PASSWORD: "ADD_PASSWORD",
}

def bp_processor_MessageId() -> bp.Processor:
    return bp.EnumProcessor(bp.Uint(8))


@dataclass
class InitializeComm(bp.MessageBase):
    # Number of bytes to serialize class InitializeComm
    BYTES_LENGTH: ClassVar[int] = 32

    public_key: List[int] = field(default_factory=lambda: [0 for _ in range(32)]) # 256bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 32, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 256, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.public_key[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.public_key[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class InitializeCommRsp(bp.MessageBase):
    # Number of bytes to serialize class InitializeCommRsp
    BYTES_LENGTH: ClassVar[int] = 48

    public_key: List[int] = field(default_factory=lambda: [0 for _ in range(32)]) # 256bit
    initialization_vector: List[int] = field(default_factory=lambda: [0 for _ in range(16)]) # 128bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 32, bp.Uint(8))),
            bp.MessageFieldProcessor(2, bp.Array(False, 16, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 384, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.public_key[di.i(0)] |= (int(b) << lshift)
        if di.field_number == 2:
            self.initialization_vector[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.public_key[di.i(0)] >> rshift) & 255
        if di.field_number == 2:
            return (self.initialization_vector[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Challange(bp.MessageBase):
    # Number of bytes to serialize class Challange
    BYTES_LENGTH: ClassVar[int] = 16

    challange_buffer: List[int] = field(default_factory=lambda: [0 for _ in range(16)]) # 128bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 16, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 128, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.challange_buffer[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.challange_buffer[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class ChallangeRsp(bp.MessageBase):
    # Number of bytes to serialize class ChallangeRsp
    BYTES_LENGTH: ClassVar[int] = 16

    challange_buffer: List[int] = field(default_factory=lambda: [0 for _ in range(16)]) # 128bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 16, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 128, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.challange_buffer[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.challange_buffer[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class HandshakeFinished(bp.MessageBase):
    # Number of bytes to serialize class HandshakeFinished
    BYTES_LENGTH: ClassVar[int] = 1

    ack: bool = False # 1bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 1, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.ack = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (int(self.ack) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class HandshakeFinishedRsp(bp.MessageBase):
    # Number of bytes to serialize class HandshakeFinishedRsp
    BYTES_LENGTH: ClassVar[int] = 1

    ack: bool = False # 1bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 1, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.ack = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (int(self.ack) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class CreateUser(bp.MessageBase):
    # Number of bytes to serialize class CreateUser
    BYTES_LENGTH: ClassVar[int] = 48

    username: List[int] = field(default_factory=lambda: [0 for _ in range(16)]) # 128bit
    password_hash: List[int] = field(default_factory=lambda: [0 for _ in range(32)]) # 256bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Array(False, 16, bp.Uint(8))),
            bp.MessageFieldProcessor(2, bp.Array(False, 32, bp.Uint(8))),
        ]
        return bp.MessageProcessor(False, 384, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.username[di.i(0)] |= (int(b) << lshift)
        if di.field_number == 2:
            self.password_hash[di.i(0)] |= (int(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.username[di.i(0)] >> rshift) & 255
        if di.field_number == 2:
            return (self.password_hash[di.i(0)] >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class CreateUserRsp(bp.MessageBase):
    # Number of bytes to serialize class CreateUserRsp
    BYTES_LENGTH: ClassVar[int] = 1

    ack: bool = False # 1bit

    def __post_init__(self):
        pass

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 1, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.ack = bool(b)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (int(self.ack) >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Messages(bp.MessageBase):
    # Number of bytes to serialize class Messages
    BYTES_LENGTH: ClassVar[int] = 98

    id: Union[int, MessageId] = MessageId.INITIALIZE_COMM
    # This field is a proxy to hold integer value of enum field 'id'
    _enum_field_proxy__id: int = field(init=False, repr=False) # 8bit
    init_comm: InitializeComm = field(default_factory=InitializeComm) # 256bit
    challange: Challange = field(default_factory=Challange) # 128bit
    handshake_finished: HandshakeFinished = field(default_factory=HandshakeFinished) # 1bit
    user_creation: CreateUser = field(default_factory=CreateUser) # 384bit

    def __post_init__(self):
        # initialize handling of enum field 'id' as `enum.IntEnum`
        if not isinstance(getattr(Messages, "id", False), property):
            self._enum_field_proxy__id = self.id
            Messages.id = property(Messages._get_id, Messages._set_id)  # type: ignore

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_id(self) -> MessageId:
        """property getter for enum proxy field"""
        return MessageId(self._enum_field_proxy__id)

    def _set_id(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__id = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_MessageId()),
            bp.MessageFieldProcessor(2, InitializeComm().bp_processor()),
            bp.MessageFieldProcessor(3, Challange().bp_processor()),
            bp.MessageFieldProcessor(4, HandshakeFinished().bp_processor()),
            bp.MessageFieldProcessor(5, CreateUser().bp_processor()),
        ]
        return bp.MessageProcessor(False, 777, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.id |= (MessageId(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.id >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        if di.field_number == 2:
            return self.init_comm
        if di.field_number == 3:
            return self.challange
        if di.field_number == 4:
            return self.handshake_finished
        if di.field_number == 5:
            return self.user_creation
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return


@dataclass
class Responses(bp.MessageBase):
    # Number of bytes to serialize class Responses
    BYTES_LENGTH: ClassVar[int] = 66

    id: Union[int, MessageId] = MessageId.INITIALIZE_COMM
    # This field is a proxy to hold integer value of enum field 'id'
    _enum_field_proxy__id: int = field(init=False, repr=False) # 8bit
    init_comm: InitializeCommRsp = field(default_factory=InitializeCommRsp) # 384bit
    challange: ChallangeRsp = field(default_factory=ChallangeRsp) # 128bit
    handshake_finished: HandshakeFinishedRsp = field(default_factory=HandshakeFinishedRsp) # 1bit
    user_creation: CreateUserRsp = field(default_factory=CreateUserRsp) # 1bit

    def __post_init__(self):
        # initialize handling of enum field 'id' as `enum.IntEnum`
        if not isinstance(getattr(Responses, "id", False), property):
            self._enum_field_proxy__id = self.id
            Responses.id = property(Responses._get_id, Responses._set_id)  # type: ignore

    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}

    def _get_id(self) -> MessageId:
        """property getter for enum proxy field"""
        return MessageId(self._enum_field_proxy__id)

    def _set_id(self, val):
        """property setter for enum proxy field"""
        self._enum_field_proxy__id = val

    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp_processor_MessageId()),
            bp.MessageFieldProcessor(2, InitializeCommRsp().bp_processor()),
            bp.MessageFieldProcessor(3, ChallangeRsp().bp_processor()),
            bp.MessageFieldProcessor(4, HandshakeFinishedRsp().bp_processor()),
            bp.MessageFieldProcessor(5, CreateUserRsp().bp_processor()),
        ]
        return bp.MessageProcessor(False, 522, field_processors)

    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.id |= (MessageId(b) << lshift)
        return

    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.id >> rshift) & 255
        return bp.byte(0)  # Won't reached

    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        if di.field_number == 2:
            return self.init_comm
        if di.field_number == 3:
            return self.challange
        if di.field_number == 4:
            return self.handshake_finished
        if di.field_number == 5:
            return self.user_creation
        return bp.NilAccessor() # Won't reached

    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s

    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)

    def bp_process_int(self, di: bp.DataIndexer) -> None:
        return